# 리눅스 운영 및 관리
## 3. 프로세스관리
###  ※ 개념 및 유형
#### - 프로세스의 개요
##### ＠ 프로세스란?
실행중인 프로그램, 프로세스번호가 부여됨.(PID)
- 백그라운드 프로세스: 사용자입력X
- 포어그라운드 프로세스: 사용자입력O, 수행종료까지 기다려야 함
##### ＠ 프로세스의 생성
- fork: 새로운 프로세스를 위해 메모리 할당. 복사본 실행
- exec: 호출한 프로세스의 메모리에 덮어씀
- 리눅스 부팅: init(PID:1) 이후에 fork방식으로 init의 자식프로세스 생성. init은 모든 프로세스의 부모 프로세스(PPID)다.
- 프로세스의 상태를 확인하는 명령: ps
---
~~~
(  )은/는 원래의 프로세스를 새로운 프로세스로 대체하는 형태로 호출한 프로세스의 메로리에 새로운 프로세스의 코드로 덮어씌워 버린다.
~~~
28. 다음 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?  
    
    ❶ exec		② fork  
    ③ inetd		④ standalone

27. 다음 중 시스템 부팅 시 리눅스 커널이 최초로 발생시키는 프로세스로 알맞은 것은?  
    ❶ init		② inetd  
    ③ bash		④ xinetd  
---
##### ＠ 프로세스의 종류
- 백그라운드로 실행하고 싶으면 명령어의 뒤에 '&'만 붙이면 된다. 다중작업(Multitasking)을 수행한다.
##### ＠ 멀티태스킹과 작업전환
- 포어그라운드 -> *백그라운드* (bg)
- 백그라운드 -> *포어그라운드* (fg)
    + 다수의 작업이 백그라운드 진행중일 때 : jobs로 작업내용 확인 후에 'fg %작업번호'하면 특정 작업번호의 프로세스가 포어그라운드로 변경됨
- [+], [-]의 의미: +가 우선순위, 작업번호를 안주면 +가 먼저 적용됨
---
22. 다음 중 백그라운드로 실행 중이고 작업번호 2번이 부여된 프로세스를 포어그라운드 프로 세스로 전환하는 명령으로 알맞은 것은?  
    ① bg &2		② bg %2  
    ③ fg &2		❹ fg %2  
---
~~~
[ihduser@www ~] $
[1]     2998 Suspended (tty output)     vim a.txt
[2]  -  2998 Suspended (tty output)     vim b.txt
[3]  +  2998 Suspended (tty output)     vim c.txt
[ihduser@www ~] $
~~~
23. 다음 결과에 해당하는 명령으로 알맞은 것은?  
    
    ① bg		② fg  
    ❸ jobs		④ kill  
-> jobs로 작업내용을 확인할 수 있다.
---

#### - 시그널과 데몬
##### ＠ 시그널?
- 특정 프로세스가 다른 프로세스에게 메세지를 보낼 때 사용
- kill -l(시그널 목록)
    + [1] SIGHUP(HUP): Hangup의 약어. 접속이 끊겨서 데몬 환경 설정 파일을 변경시키고 재시작할 때 
    + [2] SIGINT(INT): 키보드로부터 오는 인터럽트 시그널. 실행 중지. Ctrl + C
    + [3] SIGQUIT(QUIT): 키보드로부터 오는 인터럽트 시그널. 실행 중지. Ctrl + \
    + [9] SIGKILL(KILL): 무조건 종료
    + [15] SIGTERM(TERM): Terminate(정상종료)
    + [18] SIGCONT(CONT): COntinue, Stop에 의해 멈춘 프로세스 다시 실행
    + [19] SIGSTOP(STOP): 정지 시그널
    + [20] SIGTSTP(TSTP): 실행 정지, 대기신호 Ctrl + z
---
21. 다음 중 리눅스 시스템에서 사용하는 시그널 이름과 번호를 확인할 때 사용하는 명령으로 알맞은 것은?  
    ① signal		② signal -l   
    ❸ kill -l		④ kill -n  

19. 다음 중 [Ctrl]+[C]를 입력했을 때 발생하는 시그널 이름으로 알맞은 것은?  
    ❶ SIGINT		② SIGQUIT  
    ③ SIGSTOP		④ SIGCONT  
-> SIGNAL INTERRUPT  
---
##### ＠ 데몬?
- 주기적이고 지속적인 서비스 요청을 처리하기 위해 계속 실행되는 프로세스. 백그라운드로 실행된다. 서버 역할을 하는 프로그램들이 해당되고 이름뒤에 데몬을 뜻하는 d가 붙어있다.
- 데몬 실행 방법
    + standalone방식: 부팅시에 시작되서 계속 실행(ex. 웹, 메일 등)
    + inet방식: 클라이언트의 서비스 요청이 들어왔을 때만 실행, 안쓸땐 종료. 자주 사용하지 않는 프로그램. 메모리관리가 효율적(inetd데몬, xinetd 데몬)
---
~~~
주기적이고 지속적인 서비스 요청을 처리하기 위해 계속 실행되는 프로세스를 통칭하는 말이다.
~~~
26. 다음 설명에 해당하는 것은?  
    
    ① fork		② inetd  
    ❸ daemon		④ standalone  
19. 다음 중 standalone 방식과 inetd 방식에 대한 비교 설명으로 알맞은 것은?  
    ❶ inetd 방식이 standalone 방식보다 메모리 관리가 더 효율적이다.  
    ② inetd 방식이 standalone 방식보다 관련 서비스 처리가 빠르다.  
    ③ 웹과 같은 빈번한 요청이 들어오는 서비스는 inetd 방식이 적합하다.  
    ④ 사용자가 많은 서비스는 standalone 방식보다 inetd 방식이 적합하다.  
-> standalone 방식은 켜져있기 때문에 서비스 처리가 빠르고 ,빈번한 요청에 적합하여 사용자가 많을 떄 사용하는 것이 좋다.  
-> inetd 방식은 메모리 관리가 효율적이다.
---

###  ※ 프로세스 유틸리티
#### - 프로세스 관련 명령어
##### ＠ ps(process status)
~~~
$ps [option]
~~~
동작 중인 프로세스의 상태를 출력해 주는 명령. System V 계열과 BSD계열의 옵션을 정확히 사용해야 한다.

- 주요옵션
    + a: 터미널과 연관된 프로세스를 출력
    + u: 프로세스의 소유자 기준으로 출력
    + x: 데몬 프로세스처럼 터미널에 종속되지 않는 프로세스 출력. a와 결합하여 모든프로세스를 출력.
    + l: 프로세스의 정보를 길게 보여주는 옵션
    + e: 해당 프로세스에 관련된 환경변수 정보 함께 출력
    + f: 프로세스간의 상속관계를 트리 구조로 출력
    + p: 특정 PID를 지정할 때 사용(BSD계열)
    + -A: 모든 프로세스를 출력(= '-e') (System V계열)
    + -e: 모든 프로세스를 출력(= '-A')
    + -a: 세션리더(로그인셸)을 제회하고 터미널에 종속되지 않은 모든 프로세스를 출력
    + -f: 유닉스 스타일로 출력해 주는 옵션. UID, PID, PPID 등 함께 표시
    + -C 프로세스명: 지정한 프로세스만 보여준다.
    + -o 값: 출력 포맷을 지정하는 옵션.pid, tty, time, cmd
    + -p: 특정 PID를 지정(System V계열)
    + -u: 특정 사용자의 프로세스 정보 확인. 사용자 지정하지 않으면 현재 사용자 기준으로 출력.
- 사용 예
    + $ ps: 사용자와 관련된 프로세스를 출력한다.
    + $ ps aux: 시스템에 동작중인 모든 프로세스를 소유자 정보와 함께 출력한다.(BSD계열)
    + $ ps -ef |more: System V계열. 시스템에 동작 중인 모든 프로세스를 출력한다. 추가로 한 페이지씩 화면에 출력되도록 한다.
    + $ ps aux |grep sendmail: 동작중인 프로세스 중에 sendmail이라는 이름의 프로세스를 찾아서 출력한다.
- ps 명령의 목록의 다양한 항목(컬럼정보)
    + USER: BSD 계열. 프로세스 소유자의 이름
    + UID: Sytem V계열. 프로세스 소유자의 이름
    + PID: 프로세스의 식별 번호
    + %CPU: CPU 사용 비율의 추정치(BSD)
    + %MEM: MEM 사용 비율의 추정치(BSD)
    + VSZ: K단위 또는 페이지 단위의 가상메모리 사용량
    + RSS: 실제 메모리 사용량
    + TTY: 프로세스와 연결된 터미널
    + STAT: 현재 프로세스의 상태 코드
    + START: 프로세스 시작시간 또는 날짜
    + STIME: 프로세스가 시작된 시간 혹은 날짜(System V)
    + TIME: 총 CPU 사용시간
    + COMMAND: 프로세스의 실행 명령행
    + C, CP: 짧은 기간 동안의 CPU 사용률(C: System V, CP: BSD)
    + F: 프로세스의 플래그(1: fork된 경우, 4: 슈퍼유저 권한 사용자)
    + PPID: 부모 프로세스의 PID
    + PRI: 실제 실행 우선순위
    + NI: nice 우선순위 번호
- STAT의 주요값
    + R(Running): 실행 중 혹은 실행될 수 있는 상태(실행 Queue에 존재)
    + S(Sleeping): 인터럽트에 의한 sleep 상태로 특정 이벤트가 끝나기를 기다리는 상태
    + D(Disk Wait): 디스크 I/O에 의해 대기중인 상태
    + T(Traced or stopped): 정지된 상태(Suspend)
    + W: paging 상태
    + Z(Zombie): 좀비 프로세스. 작업이 종료되었으나 부모 프로세스로부터 회수되지 않아 메모리를 차지하고 있는 상태
    + X: 죽어있는 상태. 상태값으로 볼 수 없다.
    + <: 우선순위가 인위적으로 높아진 상태
    + N(Nice): 다른 사용자에 의해 우선순위가 낮아진 상태
    + L: 메모리 안에서 페이지가 잠금된 상태
    + s: session Leader
    + l: 멀티쓰레드 상태
    + +: 포어그라운드 프로세스 그룹
---
22. 다음 중 ps 명령으로 동작중인 데몬을 확인할 때 사용하는 옵션으로 알맞은 것은?  
    ① a			② d  
    ③ u			❹ x  
-> ps x는 데몬과 같은 터미널에 종속되지 않는 프로세스를 출력한다.

23. ps 명령의 상태 코드 중 작업은 종료되었으나 부모 프로세스로부터 회수되지 않았을 때 나타나는 상태 코드 값으로 알맞은 것은?  
    ① T			② W  
    ③ X			❹ Z  
---
##### ＠ pstree
프로세스의 상태를 트리구조로 출력해준다. 왼쪽에 부모 오른쪽에 자식
~~~
$ pstree [option]
~~~
- 주요 옵션
    + -a: 각 프로세스의 명령행 인자까지 보여준다.
    + -h: 현재 프로세스와 조상 프로세스를 하이라이트로 강조해서 보여준다.
    + -n: 프로세스 이름대신에 PID 값으로 정렬해서 보여준다.
    + -p: PID값을 같이 보여준다.

##### ＠ top
동작 중인 프로세스의 상태를 실시간으로 화면에 출력해주는 명령. CPU상태, 메모리상태, 부하상태 등도 확인
~~~
$ top [option]
~~~
---
24. 다음 중 실행 중인 프로세스들의 CPU 사용률을 실시간으로 확인할 때 사용하는 명령으로 알맞은 것은?  
    ❶ top		② nice  
    ③ jobs		④ renice
---
- 주요 옵션
    + -d 갱신시간: 갱신시간 설정(초단위)
    + -p: 특정 PID값을 갖는 프로세스를 모니터링할때 사용한다.
- top 명령의 목록의 다양한 항목(컬럼정보)
    + PID: 프로세스의 식별 번호
    + USER: 소유자
    + PR: Priority(우선순위)
    + NI: Nice value:(-20 ~ 19사이의 값) 작을수록 우선순위가 높아짐.
    + VIRT: 작업에 의해 사용된 가상 메모리의 총 사용량
    + RES: 프로세스가 사용하는 실제 메모리의 양(Resident size(kb))
    + SHR: 프로세스가 사용하는 공유 메모리의 양
    + S: 현재 프로세스의 상태
    + %CPU: CPU 사용량(퍼센트)
    + %MEM: MEM 사용량(퍼센트)
    + TIME+: 프로세스가 시작하여 사용한 총 CPU 시간(1/100 초 단위까지 표시)
    + COMMAND: 프로세스를 실행한 명령
    + -p: PID값을 같이 보여준다.
- top 실행상태에서의 명령
    + [SPACE]: 화면을 갱신한다.
    + h,?: 도움말을 출력한다.
    + k: kill 명령을 내린다. PID 값을 입력하면 종료 신호를 보낸다.
    + i: Zombie, idle 프로세스의 출력을 on/off한다.
    + n,#: 출력하는 프로세스의 수를 지정한다.
    + q: top을 종료한다.
    + r: Nice 값을 변경한다.
    + s: 화면을 갱신하는 시간을 변경한다.
    + F, f: 보여줄 항목을 추가하거나 삭제한다.
    + O, o: 보여줄 항목의 순서를 바꿈
    + l: op의 맨 윗줄(uptime)을 on/off한다.
    + m: 메모리 관련된 항목을 on/off 한다.
    + t: 프로세스와 CPU 항목을 on/off한다.
    + c: Command line 옵션을 on/off한다.
    + M: 프로세스의 RES 값으로 정렬한다.
    + P: %CPU 값으로 정렬한다.
    + T: Time값으로 정렬한다.
    + W: 바꾼 설정을 저장한다.
- 사용 예
~~~
$ top -d 2 -p 1222
~~~
PID 값이 1222인 프로세스를 2초 간격으로 관련 정보를 출력한다.

##### ＠ kill
프로세스에 특정한 시그널을 보내는 명령. 옵션 없이 실행하면 프로세스에 종료신호(SIGTERM:정상종료[15])를 보낸다.
~~~
# kill [option] [signal] [PID 또는 %Job_number]
~~~
---
25. 다음 중 kill 명령 실행 시에 기본적으로 전송되는 시그널 번호로 알맞은 것은?  
    ① 1			② 3  
    ③ 9			❹ 15  
-> 15번, SIGTERM, 정상종료
---
- 주요 옵션
    + -l: 시그널의 종류를 출력한다.
    + -s signal: 시그널의 이름을 지정하는 옵션
- 사용 예
~~~
# kill -l
~~~
-> 시그널의 종류를 출력한다.
~~~
# kill 724
~~~
-> PID가 724인 프로세스에 기본시그널인 15번 시그널(SIGTERM)을 보낸다. 같은 명령은 'kill -15 724', 'kill -TERM 724', 'kill -s SIGTERM 724' 등이 있다.
~~~
# kill -9 756 757 758
~~~
-> PID가 756,757,758인 프로세스를 강제 종료한다. 'kill -KILL 756 757 758', 'kill -SIGKILL 756 757 758' 라고 해도 된다.
~~~
# kill -HUP 10118
~~~
-> pid가 10118인 프로세스를 재시작한다. 'kill -1 10118'과 같다.
~~~
# kill %2
~~~
-> 작업번호가 2인 프로세스를 종료시킨다.
~~~
# kill -s SIGTERM 1702
~~~
-> PID가 1702인 프로세스에 기본 종료 시그널인 TERM을 보내서 종료한다.
---
~~~
[root@www ~] # userdel -r idhuser
userdel: user ihduser is currently used vy process 3878
[root@www ~]#
~~~
25. 다음과 같이 사용자 제거 작업이 실패하였다. 해당 작업 전에 실행해야할 명령으로 알맞은 것은?  
    
    ① kill 3878		② kill ihduser  
    ❸ kill -9 3878	④ killall -9 3878
---
##### ＠ killall
~~~
# killall [option] 프로세스명
~~~